<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>马大灯笼节 - 幸运抽奖</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Cinzel:wght@900&display=swap');

        :root {
            --primary-gold: #ffdd44;
            --primary-red: #ff3333;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            background-color: #000;
            background: radial-gradient(circle at center, #4a0e0e 0%, #1a0505 50%, #000000 100%);
            font-family: 'Cinzel', serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
        }

        /* --- LAYER 1: GOD RAYS (Back) --- */
        .god-rays {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150vmax;
            height: 150vmax;
            background: repeating-conic-gradient(rgba(255, 235, 150, 0.15) 0deg,
                    rgba(255, 235, 150, 0.15) 15deg,
                    transparent 15deg, transparent 30deg);
            box-shadow: 0 0 100px 80px rgba(255, 200, 50, 0.2);
            mix-blend-mode: screen;
            animation: rotateRays 60s linear infinite;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes rotateRays {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        .god-rays.pulsing {
            animation: rotateRays 60s linear infinite, rayPulse 2s ease-in-out infinite alternate;
        }

        @keyframes rayPulse {
            0% {
                opacity: 0.3;
                filter: brightness(1.0);
            }

            100% {
                opacity: 0.8;
                filter: brightness(1.5);
            }
        }

        /* --- LAYER 2: LANTERNS (DYNAMIC) --- */
        #lantern-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            /* Default: Low */
            transition: z-index 0.1s step-end;
        }

        /* When revealing, move lanterns BETWEEN Glass(20) and Text(30) */
        body.winner-revealed #lantern-canvas {
            z-index: 25;
        }

        /* --- LAYER 3: GREY GLASS BACKDROP (Independent Layer) --- */
        #glass-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.75);
            backdrop-filter: blur(10px);
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }

        #glass-backdrop.visible {
            opacity: 1;
        }

        /* --- LAYER 4: TEXT CONTENT (Top Layer) --- */
        /* This container holds the text and button, placed HIGHER than everything else */
        .content-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            /* Crucial: Higher than lanterns (25) */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s;
        }

        .content-layer.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* --- LAYER 5: FIREWORKS (Explosions on top) --- */
        #firework-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 40;
            pointer-events: none;
        }

        /* --- STYLING --- */
        #main-title {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            pointer-events: none;
            padding: 5vh 8vw;
            width: max-content;
            background: linear-gradient(145deg, rgba(40, 40, 40, 0.85), rgba(10, 10, 10, 0.95));
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8);
        }

        .title-chinese {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 5vw;
            color: var(--primary-gold);
            margin: 0;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8), 0 0 40px rgba(255, 160, 0, 0.8);
            letter-spacing: 12px;
            white-space: nowrap;
        }

        .title-english {
            font-family: 'Cinzel', serif;
            font-size: 1.2vw;
            color: #ffbfbf;
            letter-spacing: 8px;
            margin-top: 15px;
            text-shadow: 0 0 15px rgba(255, 50, 50, 0.8);
            opacity: 0.95;
            white-space: nowrap;
        }

        .title-sub {
            margin-top: 15px;
            font-size: 0.8vw;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        /* Scramble Text */
        #scramble-text {
            font-family: 'Cinzel', serif;
            font-weight: 900;
            font-size: 15vw;
            color: #fff;
            line-height: 1;
            font-variant-numeric: tabular-nums;
            text-shadow: 0 0 80px rgba(255, 200, 0, 1.0);
            will-change: transform;
        }

        .scrambling #scramble-text {
            animation: pulse-zoom 0.1s infinite alternate;
            color: #fffbe6;
        }

        @keyframes pulse-zoom {
            0% {
                transform: scale(0.95);
            }

            100% {
                transform: scale(1.05);
            }
        }

        /* Winner Text */
        .winner-label {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 5vw;
            color: var(--primary-gold);
            text-shadow: 0 0 30px #ff3333;
            letter-spacing: 0.5rem;
            margin-bottom: 2vh;
            animation: floatText 3s ease-in-out infinite;
        }

        .winner-number {
            font-family: 'Cinzel', serif;
            font-weight: 900;
            font-size: 18vw;
            color: #fff;
            text-shadow: 0 0 30px var(--primary-gold), 0 0 100px #ff0000;
            line-height: 1;
        }

        .number-pop {
            animation: superSlam 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes superSlam {
            0% {
                transform: scale(2.0);
                opacity: 0;
                filter: blur(10px);
            }

            100% {
                transform: scale(1);
                opacity: 1;
                filter: blur(0px);
            }
        }

        @keyframes floatText {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        #controls {
            position: absolute;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        button {
            background: linear-gradient(to bottom, #c0151a, #660000);
            border: 1px solid rgba(255, 215, 0, 0.4);
            padding: 15px 70px;
            font-size: 28px;
            font-family: 'Ma Shan Zheng', cursive;
            color: var(--primary-gold);
            cursor: pointer;
            border-radius: 50px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
            letter-spacing: 3px;
            white-space: nowrap;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 80px rgba(255, 200, 0, 0.6);
        }

        button:active {
            transform: scale(0.95);
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            background: radial-gradient(circle, transparent 40%, rgba(0, 0, 0, 0.9) 100%);
        }

        #flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-out;
            mix-blend-mode: overlay;
        }
    </style>
</head>

<body>

    <audio id="sfx-storm" src="storm.mp3" preload="auto"></audio>
    <audio id="sfx-boom" src="boom.mp3" preload="auto"></audio>

    <div id="flash"></div>
    <div class="vignette"></div>
    <div class="god-rays"></div>

    <div id="glass-backdrop"></div>

    <canvas id="lantern-canvas"></canvas>

    <div id="main-title">
        <h1 class="title-chinese">马大灯笼节</h1>
        <div class="title-english">PESTA TANGLUNG UM</div>
        <div class="title-sub">Grand Lucky Draw</div>
    </div>

    <div id="scramble-screen" class="content-layer">
        <div id="scramble-text">000</div>
    </div>

    <div id="winner-screen" class="content-layer">
        <div class="winner-label">✨ 天选之人 ✨</div>
        <div class="winner-number" id="result-text">---</div>
        <button style="margin-top: 5vh; font-size: 24px; padding: 12px 50px;" onclick="resetDraw()">下一位</button>
    </div>

    <canvas id="firework-canvas"></canvas>

    <div id="controls">
        <button id="ignite-btn" onclick="startDraw()">⚡ 启 动 ⚡</button>
    </div>

    <script>
        const Config = {
            totalParticipants: 450,
            drawDuration: 4000,
            lanternCount: 65,
            baseSpeed: 1.5,
            stormMaxSpeed: 30.0,
            fireworksCount: 50, // Reduced from 80
            confettiCount: 50   // Reduced from 150
        };

        const State = {
            mode: 'IDLE',
            width: 0,
            height: 0,
            globalSpeedMultiplier: 1.0,
            lastTime: 0,
            drumrollActive: false,
            lastDrumrollTime: 0
        };

        // --- ASSETS ---
        const lanternCache = [];
        const particleCache = []; // NEW: Sprite Cache for GPU Blitting

        function preRenderLanterns() {
            const cacheCount = 12;
            for (let i = 0; i < cacheCount; i++) {
                const size = 42 + Math.random() * 26.25;
                const c = document.createElement('canvas');
                c.width = size * 3; c.height = size * 4;
                const ctx = c.getContext('2d');
                ctx.translate(size * 1.5, size * 1.5);
                const hue = Math.floor(Math.random() * 40);

                ctx.shadowBlur = 40; ctx.shadowColor = `hsla(${hue}, 100%, 60%, 0.8)`;
                const w = size * 0.55; const h = size * 0.75;
                const grd = ctx.createLinearGradient(-w / 2, -h / 2, w / 2, h / 2);
                grd.addColorStop(0, `hsla(${hue}, 100%, 70%, 1)`);
                grd.addColorStop(1, `hsla(${hue}, 100%, 50%, 1)`);
                ctx.beginPath(); ctx.moveTo(-w / 2, -h / 2); ctx.lineTo(w / 2, -h / 2);
                ctx.lineTo(w / 3, h / 2); ctx.lineTo(-w / 3, h / 2); ctx.closePath();
                ctx.fillStyle = grd; ctx.fill();

                ctx.shadowBlur = 0; ctx.strokeStyle = "rgba(255, 255, 220, 0.7)"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-w / 2, -h / 2); ctx.lineTo(-w / 3, h / 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w / 2, -h / 2); ctx.lineTo(w / 3, h / 2); ctx.stroke();

                ctx.shadowBlur = 20; ctx.shadowColor = "#fff";
                ctx.beginPath(); ctx.arc(0, h / 4, w / 5, 0, Math.PI * 2); ctx.fillStyle = "#fff"; ctx.fill();

                lanternCache.push({ img: c, width: c.width, height: c.height });
            }
        }

        function preRenderParticles() {
            // Generate sprites for Red/Gold spectrum
            // Hues: 0-20 (Red) and 40-60 (Yellow/Gold)
            const hues = [];
            for (let i = 0; i <= 20; i += 2) hues.push(i);
            for (let i = 40; i <= 60; i += 2) hues.push(i);

            hues.forEach(hue => {
                const size = 16; // Texture size (enough for max radius + glow)
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');
                const center = size / 2;
                const radius = size * 0.25; // Base radius

                // Outer Glow
                const grad = ctx.createRadialGradient(center, center, 0, center, center, size / 2);
                grad.addColorStop(0, `hsla(${hue}, 100%, 70%, 1)`);
                grad.addColorStop(0.4, `hsla(${hue}, 100%, 50%, 0.8)`);
                grad.addColorStop(1, `hsla(${hue}, 100%, 50%, 0)`);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, size, size);

                // White Core
                ctx.beginPath();
                ctx.arc(center, center, radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = "#fff";
                ctx.fill();

                particleCache.push({ img: c, size: size, hue: hue });
            });
        }

        // --- CLASSES ---
        class Lantern {
            constructor() {
                this.reset();
                this.y = Math.random() * State.height;
                this.swingPhase = Math.random() * Math.PI * 2;
            }
            reset() {
                this.x = Math.random() * State.width;
                this.y = State.height + Math.random() * 200;
                this.baseSpeed = Math.random() * 0.5 + 0.5;
                this.sprite = lanternCache[Math.floor(Math.random() * lanternCache.length)];
                this.swingPhase = Math.random() * Math.PI * 2;
                this.swingSpeed = 0.02 + Math.random() * 0.02;
                this.scale = 0.9 + Math.random() * 0.5;
            }
            update(dt) {
                // Base upward movement
                let speed = this.baseSpeed * State.globalSpeedMultiplier * dt;

                // Storm Effect: Reverted (Standard movement)
                this.y -= speed;

                if (State.mode === 'WINNER') {
                    // Float up gently, no swing
                    this.swingPhase += this.swingSpeed * 0.1 * dt;
                } else {
                    this.swingPhase += this.swingSpeed * dt;
                    this.x += Math.sin(this.swingPhase * 0.5) * 0.2 * dt;
                }

                // Wrap around X
                if (this.x > State.width + 50) this.x = -50;
                if (this.y < -150) this.reset();
            }
            draw(ctx) {
                // Optimized: No save/restore (High Perf)
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.sin(this.swingPhase) * 0.1);
                ctx.scale(this.scale, this.scale);
                ctx.drawImage(this.sprite.img, -this.sprite.width / 2, -this.sprite.height / 2);

                // Reset Matrix directly
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }

        class Particle {
            constructor(x, y, isConfetti = false) {
                this.init(x, y, isConfetti);
            }

            init(x, y, isConfetti) {
                this.x = x; this.y = y;
                this.isConfetti = isConfetti;
                this.life = 1.0;

                if (!isConfetti) {
                    this.maxHistory = 8; // Power of 2 for Bitwise Masking
                    if (!this.historyX) {
                        this.historyX = new Float32Array(this.maxHistory);
                        this.historyY = new Float32Array(this.maxHistory);
                    }
                    this.historyIdx = 0;
                    this.historyLen = 0;
                }

                const angle = Math.random() * Math.PI * 2;
                if (isConfetti) {
                    this.vx = (Math.random() - 0.5) * 5;
                    this.vy = (Math.random() - 0.5) * 5 - 5;
                    this.drag = 0.95; this.gravity = 0.15; this.decay = 0.005;
                    this.size = Math.random() * 5 + 3;
                    this.color = `hsl(${40 + Math.random() * 20}, 100%, 75%)`;
                    this.rotation = Math.random() * Math.PI;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                } else {
                    // Firework Spark
                    const speed = Math.random() * 18 + 12; // Bigger burst radius
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.drag = 0.92; // Higher drag for air resistance
                    this.gravity = 0.15; // Heavier gravity for arc
                    this.decay = Math.random() * 0.015 + 0.01;

                    // Select sprite from cache
                    this.sprite = particleCache[Math.floor(Math.random() * particleCache.length)];
                    this.size = this.sprite.size * (0.8 + Math.random() * 0.4); // Variation

                    // Optimization: Use solid HSL and let globalAlpha handle opacity
                    this.color = `hsl(${this.sprite.hue}, 100%, 70%)`;
                }
            }

            update(dt) {
                // Save position for trail (Ring Buffer Write)
                if (!this.isConfetti) {
                    this.historyX[this.historyIdx] = this.x;
                    this.historyY[this.historyIdx] = this.y;
                    // Optimized: Bitwise Masking (Requires maxHistory to be Power of 2)
                    this.historyIdx = (this.historyIdx + 1) & 7; // & (maxHistory - 1)
                    if (this.historyLen < this.maxHistory) this.historyLen++;
                }

                this.x += this.vx * dt; this.y += this.vy * dt;
                this.vx *= this.drag; this.vy *= this.drag; this.vy += this.gravity * dt;
                this.life -= this.decay * dt;
                if (this.isConfetti) this.rotation += this.rotationSpeed * dt;
            }
            draw(ctx) {
                const alpha = Math.max(0, this.life);

                // Common alpha for both types
                ctx.globalAlpha = alpha;

                if (this.isConfetti) {
                    ctx.fillStyle = this.color;

                    // Optimization: Manual Matrix Math (Avoids internal matrix multiplication overhead)
                    // setTransform(a, b, c, d, e, f) -> (cos, sin, -sin, cos, x, y)
                    const c = Math.cos(this.rotation);
                    const s = Math.sin(this.rotation);

                    // x|0 and y|0 for integer snapping
                    ctx.setTransform(c, s, -s, c, (this.x | 0), (this.y | 0));

                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);

                    // Reset Matrix (Identity)
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                } else {
                    // Draw Trail from Ring Buffer
                    if (this.historyLen > 1) {
                        ctx.beginPath();
                        // Optimized: Bitwise Masking for finding start index
                        let startIdx = (this.historyIdx - this.historyLen + 8) & 7;
                        ctx.moveTo((this.historyX[startIdx] | 0), (this.historyY[startIdx] | 0));

                        for (let i = 1; i < this.historyLen; i++) {
                            let currIdx = (startIdx + i) & 7;
                            ctx.lineTo((this.historyX[currIdx] | 0), (this.historyY[currIdx] | 0));
                        }
                        ctx.lineTo((this.x | 0), (this.y | 0));

                        // Optimized: lineCap is set globally in resize()
                        ctx.lineWidth = this.size * 0.15; // Thinner trail than head

                        // Optimized: No string manipulation, just set color
                        ctx.strokeStyle = this.color;
                        ctx.stroke();
                    }

                    // Draw Sprite Head (GPU Blit)
                    // Alpha is already set by ctx.globalAlpha above
                    const offset = this.size / 2;
                    // Rounding here creates crisp edges and saves anti-aliasing work
                    ctx.drawImage(this.sprite.img, (this.x - offset) | 0, (this.y - offset) | 0, this.size, this.size);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        // --- RENDER LOOP ---
        const lCanvas = document.getElementById('lantern-canvas');
        const lCtx = lCanvas.getContext('2d');

        const fCanvas = document.getElementById('firework-canvas');
        const fCtx = fCanvas.getContext('2d');

        const lanterns = [];
        const particles = [];
        const particlePool = []; // Object Pool

        function init() {
            resize();
            preRenderLanterns();
            preRenderParticles(); // NEW
            for (let i = 0; i < Config.lanternCount; i++) lanterns.push(new Lantern());
            requestAnimationFrame(loop);
        }

        function resize() {
            State.width = window.innerWidth;
            State.height = window.innerHeight;
            lCanvas.width = State.width; lCanvas.height = State.height;
            fCanvas.width = State.width; fCanvas.height = State.height;

            // Optimization: Set Composite Operation ONCE (State persists until resize)
            lCtx.globalCompositeOperation = 'lighter';
            fCtx.globalCompositeOperation = 'lighter';

            // Optimization: Set Line Cap ONCE (All fireworks use round)
            fCtx.lineCap = 'round';
        }
        window.addEventListener('resize', resize);

        function loop(timestamp) {
            if (!State.lastTime) State.lastTime = timestamp;
            const deltaTime = (timestamp - State.lastTime) / 16.67;
            State.lastTime = timestamp;
            const dt = Math.min(deltaTime, 3.0);

            let targetMultiplier = 1.0;
            if (State.mode === 'STORM') targetMultiplier = Config.stormMaxSpeed;
            if (State.mode === 'WINNER') targetMultiplier = 0.5; // Slow motion ascent

            State.globalSpeedMultiplier += (targetMultiplier - State.globalSpeedMultiplier) * 0.05 * dt;

            // Optimized: Cache Screen Dimensions
            const width = State.width;
            const height = State.height;

            lCtx.clearRect(0, 0, width, height);
            // fCtx clearing moved to conditional block below

            for (let i = 0; i < lanterns.length; i++) {
                lanterns[i].update(dt);
                lanterns[i].draw(lCtx);
            }

            // Optimization: Only render firework layer if there are particles
            // This effectively pauses the GPU rasterization for this layer when idle
            if (particles.length > 0) {
                fCtx.clearRect(0, 0, width, height);

                // Optimized Loop with Swap-and-Pop + Pooling
                let i = 0;
                while (i < particles.length) {
                    const p = particles[i];
                    p.update(dt);
                    p.draw(fCtx);
                    if (p.life <= 0) {
                        // Recycle to Pool
                        particlePool.push(p);

                        // Swap with last element and pop (O(1) removal)
                        particles[i] = particles[particles.length - 1];
                        particles.pop();
                        // Do NOT increment i, re-check this new index
                    } else {
                        i++;
                    }
                }
            }

            // --- SYNCED DOM UPDATES (No Layout Thrashing) ---
            if (State.drumrollActive) {
                if (timestamp - State.lastDrumrollTime > 50) { // 50ms interval
                    const r = Math.floor(Math.random() * Config.totalParticipants) + 1;
                    els.scrambleText.textContent = r;
                    State.lastDrumrollTime = timestamp;
                }
            }

            requestAnimationFrame(loop);
        }

        // --- GAME LOGIC ---
        let scrambleInterval;
        const sfxStorm = document.getElementById('sfx-storm');
        const sfxBoom = document.getElementById('sfx-boom');

        const els = {
            glass: document.getElementById('glass-backdrop'),
            scrambleScreen: document.getElementById('scramble-screen'),
            winnerScreen: document.getElementById('winner-screen'),
            scrambleText: document.getElementById('scramble-text'),
            resultText: document.getElementById('result-text'),
            igniteBtn: document.getElementById('ignite-btn'),
            title: document.getElementById('main-title'),
            flash: document.getElementById('flash'),
            godRays: document.querySelector('.god-rays')
        };

        function startDraw() {
            els.igniteBtn.style.opacity = '0';
            els.igniteBtn.style.pointerEvents = 'none';
            els.title.style.opacity = '0';
            els.title.style.transform = 'translate(-50%, -50%) scale(0.8)';

            try { sfxStorm.currentTime = 0; sfxStorm.play(); } catch (e) { }

            State.mode = 'STORM';

            // Show Glass + Scramble
            els.godRays.classList.add('pulsing');
            els.glass.classList.add('visible');
            els.scrambleScreen.classList.add('visible');
            els.scrambleScreen.classList.add('scrambling');

            // Start Drumroll loop (Synced with Render Loop)
            State.drumrollActive = true;
            State.lastDrumrollTime = 0;

            setTimeout(revealWinner, Config.drawDuration);
        }

        function getSecureRandomNumber(max) {
            const array = new Uint32Array(1);
            window.crypto.getRandomValues(array);
            return Math.floor((array[0] / 4294967296) * max) + 1;
        }

        function revealWinner() {
            // Stop Drumroll
            State.drumrollActive = false;

            const winningNumber = getSecureRandomNumber(Config.totalParticipants);

            // 1. Fade out scramble first
            els.scrambleScreen.classList.remove('visible');
            els.scrambleScreen.classList.remove('scrambling');

            // 2. Play sound and Flash
            try { sfxStorm.pause(); sfxBoom.currentTime = 0; sfxBoom.play(); } catch (e) { }

            els.flash.style.opacity = '1';
            // 3. Reveal winner inside the flash
            setTimeout(() => {
                els.godRays.classList.remove('pulsing');

                // Fade out flash slowly
                els.flash.style.opacity = '0';

                State.mode = 'WINNER';

                // Set Body Class for Z-Index change
                document.body.classList.add('winner-revealed');

                els.resultText.innerText = winningNumber;
                els.winnerScreen.classList.add('visible');

                els.resultText.classList.remove('number-pop');
                void els.resultText.offsetWidth;
                els.resultText.classList.add('number-pop');

                spawnExplosion(State.width / 2, State.height / 2, true);
                setTimeout(() => spawnExplosion(State.width / 2 - 300, State.height / 2, false), 200);
                setTimeout(() => spawnExplosion(State.width / 2 + 300, State.height / 2, false), 400);

            }, 300); // Wait 300ms (during whiteout) to switch
        }

        function resetDraw() {
            document.body.classList.remove('winner-revealed');
            els.winnerScreen.classList.remove('visible');
            els.glass.classList.remove('visible'); // Hide glass

            els.igniteBtn.style.opacity = '1';
            els.igniteBtn.style.pointerEvents = 'auto';
            els.title.style.opacity = '1';
            els.title.style.transform = 'translate(-50%, -50%) scale(1)';

            State.mode = 'IDLE';
            particles = [];
        }

        function spawnExplosion(x, y, includeConfetti) {
            function spawn(isConfetti) {
                let p;
                if (particlePool.length > 0) {
                    p = particlePool.pop();
                    p.init(x, y, isConfetti);
                } else {
                    p = new Particle(x, y, isConfetti);
                }
                particles.push(p);
            }

            for (let i = 0; i < Config.fireworksCount; i++) {
                spawn(false);
            }
            if (includeConfetti) {
                for (let i = 0; i < Config.confettiCount; i++) {
                    spawn(true);
                }
            }
        }

        init();

    </script>
</body>

</html>